// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract HealthEMR{
    address public owner;

    struct ServiceProvider{
        string publicKey;
    }

    struct Permission {
        bool read;
        bool write;
        string reEncKey; // reencrypt key generated by nuCypher
    }

    struct Token {
        int status;
        bool read;
        bool write;
        string reEncKey; // reencrypt key generated by nuCypher
    }

    struct EMR {
        string hash;
        address issuer;
    }

    struct Patient {
        string publicKey;
        mapping(address => Permission) permissions;
        mapping(bytes32 => Token) tokens;
        bool closed;
        EMR[] EMRs;
    }

    mapping (address => ServiceProvider) public serviceProviders;
    mapping (address => Patient) public patients;

    event tokenVerified(bytes32 hash, address patient, address serviceProvider);
    event emrAdded(address patient, address serviceProvider, string emrHash);
    event patientAccountChanged(address oldAccountAddress, string newAccountPublicKey, string reEncKey);

    constructor(){
        owner = msg.sender;
    }

    modifier onlyOwner(){
        require(msg.sender == owner, "not owner");
        _;
    }

    // Convert an hexadecimal character to their value
    // reference https://bscscan.com/contractdiffchecker?a1=0x7aff6e4a3b7071e17f5dfe9883c1511d22127b7a
    function fromHexChar(uint8 c) internal pure returns (uint8 r) {
        if (bytes1(c) >= bytes1('0') && bytes1(c) <= bytes1('9')) {
            r = c - uint8(bytes1('0'));
            return r;
        }
        if (bytes1(c) >= bytes1('a') && bytes1(c) <= bytes1('f')) {
            r = 10 + c - uint8(bytes1('a'));
            return r;
        }
        if (bytes1(c) >= bytes1('A') && bytes1(c) <= bytes1('F')) {
            r = 10 + c - uint8(bytes1('A'));
            return r;
        }
    }
    
    // Convert an hexadecimal string to raw bytes
    function fromHex(string memory s) internal pure returns (bytes memory) {
        bytes memory ss = bytes(s);
        require(ss.length%2 == 0); // length must be even
        bytes memory r = new bytes(ss.length/2);
        for (uint i=0; i<ss.length/2; ++i) {
            r[i] = bytes1(fromHexChar(uint8(ss[2*i])) * 16 +
                        fromHexChar(uint8(ss[2*i+1])));
        }
        return r;
    }

    //Register Patient 
    // address conversion from uint to bytes https://github.com/ConsenSysMesh/addresstoip/issues/1
    function addPatient(string memory _publicKey) public onlyOwner{
        if(address(uint160 (uint256 (keccak256(fromHex(_publicKey))))) == msg.sender) {
            patients[msg.sender].publicKey = _publicKey;
        }
    }

    // function to register service provider 
    function addServiceProvider(string memory _publicKey) public onlyOwner{
        if(address(uint160(uint256(keccak256(fromHex(_publicKey))))) == msg.sender) {
            serviceProviders[msg.sender].publicKey = _publicKey;
        }
    }

    //Patient:
    //InQRCode include token string, address and private key 
    //Adds the hash of token and derivation key in Blockchain
    function addToken(bytes32 _hash, bool _read, bool _write, string memory _reEncKey) public onlyOwner{
        if(patients[msg.sender].tokens[_hash].status == 0 && patients[msg.sender].closed == false) {
            patients[msg.sender].tokens[_hash].status = 1;
            patients[msg.sender].tokens[_hash].read = _read;
            patients[msg.sender].tokens[_hash].write = _write;
            patients[msg.sender].tokens[_hash].reEncKey = _reEncKey;
        }
    }

    //Service Provider proves the token to get access
    //https://ethereum.stackexchange.com/questions/55020/sha256-output
    function requestAccess(string memory _token, address _patient) public onlyOwner{
        bytes32 hash = sha256(abi.encodePacked(_token));
        if(patients[_patient].tokens[hash].status == 1) {
            patients[_patient].tokens[hash].status = 2;
            patients[_patient].permissions[msg.sender].read = patients[_patient].tokens[hash].read;
            patients[_patient].permissions[msg.sender].write = patients[_patient].tokens[hash].write;
            patients[_patient].permissions[msg.sender].reEncKey = patients[_patient].tokens[hash].reEncKey;
            emit tokenVerified(hash, _patient, msg.sender);
        }
    }

    //XXXXXXXXX
    
    //Function to add EMR 
    function addEMR(address _patient, string memory _hash) public onlyOwner{
        if(patients[_patient].permissions[msg.sender].write == true) {
            patients[_patient].EMRs.push(EMR(_hash, msg.sender));
            emit emrAdded(_patient, msg.sender, _hash);
        }
    }

    //Get Patient's public key
    function getPatientPublicKey(address _patient) public view returns(string memory publicKey){
        return(patients[_patient].publicKey);
    }

    // Check if patient's address is closed 
    function isPatientProfileClosed(address patient) public view returns(bool isClosed) {
        return(patients[patient].closed);
    }

    //function to get service provider public key 
    function getServiceProviderPublicKey(address _serviceProvider) public view returns(string memory publicKey){
        return(serviceProviders[_serviceProvider].publicKey);
    }

    //Function to revoke service provider access 
    function revokeServiceProviderAccess(address _serviceProvider) public {
        patients[msg.sender].permissions[_serviceProvider].read = false;
        patients[msg.sender].permissions[_serviceProvider].write = false;
    }

    function getToken(address _patient, bytes32 _hash) public view returns(int status, bool read, bool write, string memory reEncKey){
        return(patients[_patient].tokens[_hash].status, patients[_patient].tokens[_hash].read, patients[_patient].tokens[_hash].write, patients[_patient].tokens[_hash].reEncKey);
    }

    //Change your keys to revoke old accounts and move EMR to new account
    function changePatientAccount(string memory _reEncKey, address _newAddress, string memory _newPublicKey) public {
        patients[msg.sender].closed = true;
        if(address(uint160(uint256(keccak256(fromHex(_newPublicKey))))) == _newAddress) {
            patients[_newAddress].publicKey = _newPublicKey;
            emit patientAccountChanged(msg.sender, patients[msg.sender].publicKey, _reEncKey);
        }
    }
    
}
